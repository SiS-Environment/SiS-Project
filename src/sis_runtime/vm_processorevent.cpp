////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Includes
//
#include "vm_processorevent.h"
#include "vm_processor.h"
#include "vm_controller.h"
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace sis {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace vm {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


bool CProcEvent::Eval( CVMEventManager* pEventManager ) const
{
	if ( nullptr == pEventManager )
		return false;

	CProcessor* pProcessor = dynamic_cast<CProcessor*>( pEventManager );
	if ( nullptr == pProcessor )
		return false;
	else
		Eval( pProcessor );

	return true;
}


void CBreakEvent::Eval( CProcessor* pProcessor ) const
{
	pProcessor->Stop();
}


void CContinueEvent::Eval( CProcessor* pProcessor ) const
{
	pProcessor->Continue();
}


void CStepInEvent::Eval( CProcessor* pProcessor ) const
{
	pProcessor->StepIn();
}


void CStepOutEvent::Eval( CProcessor* pProcessor ) const
{
	pProcessor->StepOut();
}


void CStepOverEvent::Eval( CProcessor* pProcessor ) const
{
	pProcessor->StepOver();
}


void CNewProcessorEvent::Eval( CProcessor* pProcessor ) const
{
	CController* pController = pProcessor->GetContoller();
	if ( nullptr != pController )
		pController->RunNewProcessor();
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
} // namespace vm
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
} // namespace sis
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////